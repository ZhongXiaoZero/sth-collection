1、Tomcat服务器及由webpack提供的本地开发服务器的区别

Tomcat服务器是一个免费的开发源代码的web应用服务器，属于轻量级应用服务器。
weback里面的webpack-dev-server组件，可以提供一个可选的本地开发服务器，这个本地服务器基于node.js构建。由于是组件，所以需要单独安装作为项目依赖。


2、javascript的浅克隆和深克隆

首先，克隆只针对对象、数组、函数等复杂数据
浅克隆 —— 将栈内存中的引用复制一份，献给一个新的内容，本质上两个指向推内存中的同一个地址，内容也相同，其中一个变化另一个内容也会变化（根本改上的是同一个对象）
深克隆 —— 创建一个新的空对象，开辟一块内存，然后将原对象中的数据全部复制偶去，完全切断两个对象间的联系


3、JavaScript函数节流和函数防抖之间的区别

函数节流 —— 一定时间内js方法只跑一次。比如人的眼睛，在一定时间内只眨眼一次。标识位声明记录当前代码是否执行

函数防抖 —— 指频繁触发的情况下，只有足够的空闲时间，才执行代码一次。比如生活中的坐公交，就是一定时间内，如果有人陆续刷卡上车司机就不会开车。


4、事件机制
dom事件通常会有三种情况：
捕获阶段：从外向里依次查找元素。
目标阶段：从当前事件源本身的操作。
冒泡阶段：从内到外依次触发相关的行为


5、preventDefault，stopPropagation和return false 的区别

preventDefault
阻止默认行为触发，即标签本身具备的功能。
对于默认行为，浏览器优先实行事件函数后实行默认行为。

stopPropagation
阻止事件冒泡。
方法具有兼容性问题，IE8及以前版本都不支持，IE的事件对象包含特有的属性cancelBubble，只要将它赋值为true，即可阻止事件继续。

return false 
包含特有退出执行 return false 之后的所有触发事件和动作都不会被执行，有时候 return false 可以用来替代 stopPropagation() 和 preventDefault()来阻止默认行为发生和冒泡。


6、当开发测试的过程或者线上出现问题时，如何快速锁定问题？（本人见解）

首先，你得知道问题是什么，出现了什么问题，第二，你得分析确认这个问题需要谁来解决，第三，确认好可能是自己这边导致后，从现象开始分析。举几个例子：

（1）比如某个接口的某些字段可能会有问题，所以需要确认页面是否用到这些字段。那就从接口开始找，找到接口调用的地方和接口返回数据存储的地方，然后查找那些调用这些数据的地方（一般会和调用接口的地方一样），最后就可以查出页面有调用到哪些数据了

（2）当一需求上线了，而且在线上跑了一段时间并且有流量，突然某一天，用户反馈提示异常。这时候，你需要先定为是前端问题还是后端问题。直接的方法是，这个提示的返回是前端返回的还是后端返回的，如果是后端返回的，就应该先让后端查日志，排查问题。如果前端返回的，你就先找到这个提示在哪里，如何触发提示，里面的逻辑是否正确。按这个思路来找问题。

（3）如果某个项目的需求上线了，不久发现某次上的需求的内容不见了，那需要首先检查一下对应的开发分支是是否合漏以前的代码，若是的话需及时通知相关人员做紧急发布。（所以千万要注意开发时的分支是否是完整的）如果分支没问题那就有可能是打包出了问题。如果都没问题，那就可能是发布存在问题

（4）在测试过程中，如果发现某个地方存在问题，但是并不是每次都会出现。这个时候，先不要看代码，一定得知道出现问题的规律，什么情况下可以稳定重现，才真正进入查问题的流程

（5）比如说进入回归冒烟的时候，或者说每次发布的时候都需要更新版本号。第一天更新版本后到回归环境中可以访问，但是到了第二天却发现测试的页面无法访问，但是其他的却可以访问。首先确认是否是缓存问题，清掉缓存。发现还是如此，那么可以通过抓包的方式观察那些文件的版本号是否为最新，假如非最新，即可确定问题所在。


7、关于setState()

setState()将需要处理的变化塞入组件的state对象中，并告诉该组件及其子组件需要用更新的状态来重新渲染。这是用用于响应事件处理和服务端响应的更新用户界面的主要方式。
注意setState()不会立刻更新组件，其可能是批处理或推迟更新。这使得在调用setSta立刻读取this.state会存在一个潜在陷阱。代替之，可以使用componentDidUpdate或一个setState回调（setState(updater, callback)），当中的每个方法都会保证在更新被应用之后触发。

8、使用.gitignore来忽略特殊文件
这个文件的作用就是告诉Git哪些文件不需要添加到版本管理中。








